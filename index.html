<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Prisoner's Dilemma — Multiplayer Tournament</title>

  <!-- Tailwind CSS CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- PeerJS -->
  <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>

  <style>
    /* small helper so cards render nicely */
    .card { background: white; border-radius: 1rem; padding: 1rem; box-shadow: 0 6px 18px rgba(2,6,23,0.08); }
    body { background: linear-gradient(180deg,#f0f9ff,#eef2ff); }
  </style>
</head>
<body class="min-h-screen font-sans text-slate-800">

  <div class="max-w-6xl mx-auto p-6">

    <header class="mb-6">
      <h1 class="text-3xl font-extrabold">Prisoner's Dilemma — Tournament Builder</h1>
      <p class="text-sm text-slate-600 mt-1">Choose Leader or Player. Players edit strategies and send to the Leader (P2P). Leader runs tournament and shows live leaderboard.</p>
    </header>

    <!-- Role selection -->
    <div id="roleSelection" class="grid grid-cols-2 gap-6 mb-6">
      <button id="beLeader" class="card hover:scale-[1.01] transition-transform flex flex-col items-start gap-2">
        <h2 class="text-xl font-semibold">Leader</h2>
        <p class="text-slate-500">Create room, watch realtime leaderboard and start tournament. (No strategy editor)</p>
      </button>
      <button id="bePlayer" class="card hover:scale-[1.01] transition-transform flex flex-col items-start gap-2">
        <h2 class="text-xl font-semibold">Player</h2>
        <p class="text-slate-500">Join a room, edit character strategy and send it to the leader.</p>
      </button>
    </div>

    <!-- Leader UI -->
    <div id="leaderUI" class="hidden card">
      <div class="flex gap-4 items-start">
        <div class="flex-1">
          <label class="block text-sm font-medium text-slate-700">Leader display name</label>
          <input id="leaderName" class="mt-1 block w-full border rounded px-3 py-2" placeholder="Your name (leader)" />
        </div>
        <div class="w-48">
          <button id="createRoomBtn" class="mt-6 w-full bg-indigo-600 text-white py-2 rounded">Create room</button>
        </div>
      </div>

      <div id="roomInfo" class="mt-4 bg-slate-50 rounded p-4 border">
        <div><strong>Room ID:</strong> <span id="roomId">—</span></div>
        <div class="text-sm text-slate-500 mt-1">Players enter this ID to join your room.</div>
      </div>

      <div class="mt-6">
        <div class="flex items-center justify-between">
          <h3 class="text-lg font-semibold">Realtime Leaderboard</h3>
          <div>
            <button id="startTournament" class="bg-emerald-500 text-white px-3 py-1 rounded disabled:opacity-50" disabled>Start tournament</button>
          </div>
        </div>

        <div id="leaderboard" class="mt-3 grid gap-2">
          <!-- leaderboard rows inserted here -->
          <div class="p-4 text-slate-500">No players yet — leaderboard will populate as players join.</div>
        </div>
        
        <div class="mt-6">
          <h3 class="text-lg font-semibold">Tournament Logs</h3>
          <div class="mt-2 flex items-center gap-2">
            <button id="downloadLogs" class="px-3 py-1 border rounded">Download logs</button>
            <button id="clearLogs" class="px-3 py-1 border rounded">Clear</button>
          </div>
          <pre id="logsView" class="mt-2 p-3 bg-gray-50 rounded max-h-64 overflow-auto text-sm"></pre>
        </div>
      </div>
    </div>

    <!-- Player UI -->
    <div id="playerUI" class="hidden card">
      <div class="grid grid-cols-3 gap-4">
        <div>
          <label class="block text-sm font-medium">Your display name</label>
          <input id="playerName" class="mt-1 block w-full border rounded px-3 py-2" placeholder="Alice" />
        </div>
        <div>
          <label class="block text-sm font-medium">Room ID</label>
          <input id="playerRoomId" class="mt-1 block w-full border rounded px-3 py-2" placeholder="paste room id" />
        </div>
        <div class="flex items-end">
          <button id="joinRoomBtn" class="w-full bg-indigo-600 text-white py-2 rounded">Join room</button>
        </div>
      </div>

      <div id="playerRoomInfo" class="mt-4 bg-slate-50 rounded p-4 border hidden">
        <div><strong>Connected to room:</strong> <span id="playerConnectedRoom">—</span></div>
        <div class="text-sm text-slate-500 mt-1">Status: <span id="playerStatus">Not connected</span></div>
      </div>

      <div class="mt-6 grid grid-cols-2 gap-6">
        <div class="card">
          <h4 class="font-semibold">Character settings</h4>
          <div class="mt-3">
            <label class="block text-sm">Character name</label>
            <input id="charName" class="mt-1 block w-full border rounded px-3 py-2" placeholder="My AI" />
          </div>
          <div class="mt-3">
            <label class="block text-sm">Initial action</label>
            <select id="initialAction" class="mt-1 block w-full border rounded px-3 py-2">
              <option value="cooperate">Cooperate</option>
              <option value="cheat">Cheat</option>
            </select>
            <p class="text-xs text-slate-500 mt-1">Used for the first move or when no rule triggers.</p>
          </div>

          <div class="mt-4">
            <h5 class="font-medium">Rules (applied top → bottom)</h5>
            <div id="rulesList" class="mt-2 space-y-3"></div>
            <div class="mt-3 flex gap-2">
              <button id="addIfThen2Rule" class="px-3 py-1 border rounded">Add If→Then rule (2 past clauses)</button>
              <button id="addIfThenRule" class="px-3 py-1 border rounded">Add If→Then rule</button>
            </div>
          </div>

          <div class="mt-4">
            <button id="sendStrategyBtn" class="w-full bg-indigo-600 text-white py-2 rounded disabled:opacity-50" disabled>Send strategy to leader</button>
          </div>
        </div>

        <div class="card">
          <h4 class="font-semibold">Room / Leader</h4>
          <div id="connectedLeaderInfo" class="mt-2 text-sm text-slate-600">Not connected</div>

          <h4 class="font-semibold mt-6">Preview JSON</h4>
          <pre id="strategyJSON" class="mt-2 p-3 bg-gray-50 rounded max-h-72 overflow-auto text-sm"></pre>
        </div>
      </div>
    </div>

    <footer class="mt-6 text-sm text-slate-500">Prototype — Tailwind + PeerJS. Open the file in two or more windows to test (leader creates a room ID and players connect to it).</footer>
  </div>

<script>
/* ============================
   App state & utilities
   ============================ */
let role = null; // 'leader' | 'player'
let peer = null;
let myPeerId = null;
let leaderPeerId = null;
let connections = {};        // leader: peerId -> DataConnection
let leaderInfo = {};         // leader: peerId -> {name,charName,points,joinedAt}
let strategies = {};         // leader collects: peerId -> strategy
let locked = false;          // true while tournament running or locked
const ROUNDS_PER_EPOCH = 10;
const EPOCHS = 10;
let tournamentLogs = [];

// DOM helpers
const $ = id => document.getElementById(id);
function escapeHtml(s){ if(!s) return ''; return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

/* ============================
   Role selection & peer init
   ============================ */
$('beLeader').addEventListener('click', ()=>{
  role='leader';
  $('roleSelection').classList.add('hidden');
  $('leaderUI').classList.remove('hidden');
  initPeer();
});
$('bePlayer').addEventListener('click', ()=>{
  role='player';
  $('roleSelection').classList.add('hidden');
  $('playerUI').classList.remove('hidden');
  initPeer();
});

function initPeer(){
  peer = new Peer();
  peer.on('open', id => {
    myPeerId = id;
    console.log('My peer id:', id);
    if(role==='leader'){
      $('roomId').textContent = id;
      $('createRoomBtn').disabled = true; // auto-created
      $('startTournament').disabled = false;
    } else {
      $('playerStatus').textContent = 'Ready (peer id '+id+')';
    }
  });

  peer.on('connection', conn => {
    if(role !== 'leader') {
      // players don't accept inbound connections
      conn.on('open', ()=> conn.close());
      return;
    }
    const pid = conn.peer;
    connections[pid] = conn;
    leaderInfo[pid] = leaderInfo[pid] || { name: 'Player '+(Object.keys(leaderInfo).length+1), charName:'-', points:0, joinedAt: Date.now(), peerId:pid };

    conn.on('data', raw => {
      let data = raw;
      if(typeof raw === 'string') {
        try{ data = JSON.parse(raw); }catch(e){}
      }
      handleIncomingFromPlayer(pid, data);
    });
    conn.on('close', ()=> {
      delete connections[pid];
      delete leaderInfo[pid];
      delete strategies[pid];
      renderLeaderboard();
    });
    // request hello
    conn.send(JSON.stringify({type:'request-hello'}));
    renderLeaderboard();
  });
}

/* ============================
   Leader: handle player messages
   ============================ */
function handleIncomingFromPlayer(peerId, data){
  if(!data || !data.type) return;
  if(data.type === 'hello'){
    leaderInfo[peerId] = Object.assign(leaderInfo[peerId] || {}, { name: data.name, charName: data.charName });
    renderLeaderboard();
  }
  if(data.type === 'strategy'){
    if(locked){
      connections[peerId].send(JSON.stringify({type:'error', message:'Tournament already started — strategies locked'}));
      return;
    }
    strategies[peerId] = data.strategy;
    leaderInfo[peerId] = Object.assign(leaderInfo[peerId] || {}, { charName: data.strategy.characterName || data.characterName || 'Unnamed' });
    renderLeaderboard();
    connections[peerId].send(JSON.stringify({type:'received', message:'Strategy received'}));
  }
}

/* ============================
   Leader: UI actions
   ============================ */
$('createRoomBtn').addEventListener('click', ()=>{
  // peer created automatically in initPeer when role set
  if(!peer) initPeer();
});

$('startTournament').addEventListener('click', ()=>{
  if(role!=='leader') return;
  if(Object.keys(connections).length < 1){
    if(!confirm('No players connected. Start anyway?')) return;
  }
  locked = true;
  // notify players
  for(const pid in connections) connections[pid].send(JSON.stringify({type:'tournament-start'}));
  // run tournament
  runTournament();
});

/* ============================
   Render leaderboard (leader)
   ============================ */
function renderLeaderboard(){
  const el = $('leaderboard');
  el.innerHTML = '';
  const players = Object.keys(leaderInfo).map(pid => Object.assign({peerId:pid}, leaderInfo[pid]));
  // default order = join order
  players.sort((a,b)=> (a.joinedAt || 0) - (b.joinedAt || 0));
  players.forEach((p, idx) => {
    p.points = p.points || 0;
    const div = document.createElement('div');
    div.className = 'flex items-center justify-between p-3 bg-white rounded-lg shadow-sm';
    div.innerHTML = `
      <div class="flex items-center gap-3">
        <div class="w-10 h-10 rounded-full bg-indigo-100 flex items-center justify-center font-semibold text-indigo-700">${idx+1}</div>
        <div>
          <div class="font-medium">${escapeHtml(p.charName||'Unnamed')}</div>
          <div class="text-xs text-slate-500">${escapeHtml(p.name||'Player')}</div>
        </div>
      </div>
      <div class="text-right">
        <div class="text-lg font-semibold">${p.points}</div>
        <div class="text-xs text-slate-400">points</div>
      </div>
    `;
    el.appendChild(div);
  });
  if(players.length===0){
    el.innerHTML = '<div class="p-4 text-slate-500">No players yet. Players connect using the Room ID above.</div>';
  }
  // broadcast to players
  broadcastLeaderboardUpdate();
}

/* ============================
   Broadcast to players
   ============================ */
function broadcastLeaderboardUpdate(){
  const payload = { type:'leaderboard', data: Object.keys(leaderInfo).map(pid=>({peerId:pid, name:leaderInfo[pid].name, charName:leaderInfo[pid].charName, points:leaderInfo[pid].points||0})) };
  for(const pid in connections){
    try{ connections[pid].send(JSON.stringify(payload)); }catch(e){}
  }
}

/* ============================
   Player: connect to leader
   ============================ */
$('joinRoomBtn').addEventListener('click', ()=>{
  const rid = $('playerRoomId').value.trim();
  const name = $('playerName').value.trim() || 'Player';
  if(!rid){ alert('Enter Room ID'); return; }
  leaderPeerId = rid;
  const conn = peer.connect(leaderPeerId);
  conn.on('open', ()=>{
    $('playerRoomInfo').classList.remove('hidden');
    $('playerConnectedRoom').textContent = leaderPeerId;
    $('playerStatus').textContent = 'Connected';
    connections[leaderPeerId] = conn;
    conn.send(JSON.stringify({type:'hello', name, charName: $('charName').value || 'Unnamed'}));
    $('sendStrategyBtn').disabled = false;
    conn.on('data', d => {
      let msg = d;
      try{ if(typeof d === 'string') msg = JSON.parse(d); }catch(e){}
      handleIncomingFromLeader(msg);
    });
  });
  conn.on('close', ()=>{ $('playerStatus').textContent = 'Disconnected'; $('sendStrategyBtn').disabled = true; });
});

function handleIncomingFromLeader(msg){
  if(!msg || !msg.type) return;
  if(msg.type === 'request-hello'){
    const name = $('playerName').value.trim() || 'Player';
    connections[leaderPeerId].send(JSON.stringify({type:'hello', name, charName: $('charName').value || 'Unnamed'}));
  }
  if(msg.type === 'received'){
    alert('Leader: ' + msg.message);
  }
  if(msg.type === 'error'){
    alert('Leader error: ' + msg.message);
  }
  if(msg.type === 'tournament-start'){
    $('sendStrategyBtn').disabled = true;
    $('playerStatus').textContent = 'Tournament started — strategies locked';
  }
  if(msg.type === 'leaderboard'){
    renderPlayerLeaderboard(msg.data);
  }
  if(msg.type === 'tournament-end'){
    $('playerStatus').textContent = 'Tournament ended';
  }
}

function renderPlayerLeaderboard(list){
  // create a small preview near player UI
  const containerId = 'player-leaderboard-preview';
  let container = document.getElementById(containerId);
  if(!container){
    container = document.createElement('div');
    container.id = containerId;
    container.className = 'mt-4 p-4 bg-slate-50 rounded text-sm';
    $('playerUI').appendChild(container);
  }
  // sort by points desc
  list.sort((a,b)=> (b.points||0) - (a.points||0));
  const html = list.map((p, i) => `<div class="flex justify-between py-1"><div>${i+1}. ${escapeHtml(p.charName||p.name)}</div><div class="font-semibold">${p.points||0}</div></div>`).join('');
  container.innerHTML = `<strong>Leaderboard</strong>${html}`;
}

/* ============================
   Player: send strategy
   ============================ */
$('sendStrategyBtn').addEventListener('click', ()=>{
  if(!leaderPeerId || !connections[leaderPeerId] || connections[leaderPeerId].open===false) { alert('Not connected to leader'); return; }
  if(locked){ alert('Tournament has started — cannot send'); return; }
  const strategy = buildStrategyFromUI();
  connections[leaderPeerId].send(JSON.stringify({type:'strategy', strategy}));
  alert('Strategy sent to leader');
});

/* ============================
   Strategy editor (UI + JSON)
   Requirements:
    - Past rules: "<you/opponent> has <cheated/cooperated> <n|all> times after you change your action"
    - If-Then: "if <single past clause> then <action block>"
    - Action block: "you will <cheat/cooperate/random> in next <n|all> moves"
   ============================ */
function buildStrategyFromUI(){
  const characterName = $('charName').value || 'Unnamed';
  const initial = $('initialAction').value;
  const rules = [];
  const nodes = Array.from(document.querySelectorAll('.rule-item'));
  nodes.forEach(node=>{
    const kind = node.dataset.kind;
    if(kind === 'ifthen'){
      const past = node.querySelector('.cond-past');
      const actor = past.querySelector('.past-actor').value;
      const action = past.querySelector('.past-action').value;
      const count = past.querySelector('.past-count').value;
      const roundCount = node.querySelector('.round-count').value;
      const thenAction = node.querySelector('.then-action').value;
      rules.push({type:'ifthen', condition:{type:'past', past:{actor, action, count}, roundCount:parseInt(roundCount)||1}, then:{action:thenAction}});
    } else if(kind === 'ifthen2'){
      const past1 = node.querySelector('.cond-past-1');
      const actor1 = past1.querySelector('.past-actor').value;
      const action1 = past1.querySelector('.past-action').value;
      const count1 = past1.querySelector('.past-count').value;
      const past2 = node.querySelector('.cond-past-2');
      const actor2 = past2.querySelector('.past-actor').value;
      const action2 = past2.querySelector('.past-action').value;
      const count2 = past2.querySelector('.past-count').value;
      const roundCount = node.querySelector('.round-count').value;
      const thenAction = node.querySelector('.then-action').value;
      rules.push({
        type:'ifthen',
        condition:{
          type:'and',
          clauses:[
            {type:'past', past:{actor:actor1, action:action1, count:count1}},
            {type:'past', past:{actor:actor2, action:action2, count:count2}}
          ],
          roundCount:parseInt(roundCount)||1
        },
        then:{action:thenAction}
      });
    }
  });
  return {characterName, initial, rules};
}

function renderStrategyJSON(){
  const s = buildStrategyFromUI();
  $('strategyJSON').textContent = JSON.stringify(s, null, 2);
}

// add If-Then rule (2 Past clauses with AND)
$('addIfThen2Rule').addEventListener('click', ()=>{
  const node = document.createElement('div'); node.className='rule-item p-3 border rounded'; node.dataset.kind='ifthen2';
  node.innerHTML = `
    <div class="flex items-center justify-between">
      <div class="font-medium">If → Then rule (2 past clauses)</div>
      <button class="text-xs text-slate-500 remove-rule">Remove</button>
    </div>
      <div class="mt-2">
        <div class="text-xs text-slate-500">Condition (two Past clauses, AND)</div>
        <div class="mt-2 grid grid-cols-1 gap-3">
          <div class="cond-past-1 grid grid-cols-3 gap-2">
            <select class="past-actor border rounded px-2 py-1"><option value="you">you</option><option value="opponent">opponent</option></select>
            <select class="past-action border rounded px-2 py-1"><option value="cooperated">cooperated</option><option value="cheated">cheated</option></select>
            <input class="past-count border rounded px-2 py-1" placeholder="n or all" value="1" />
          </div>
          <div class="cond-past-2 grid grid-cols-3 gap-2">
            <select class="past-actor border rounded px-2 py-1"><option value="you">you</option><option value="opponent">opponent</option></select>
            <select class="past-action border rounded px-2 py-1"><option value="cooperated">cooperated</option><option value="cheated">cheated</option></select>
            <input class="past-count border rounded px-2 py-1" placeholder="n or all" value="1" />
          </div>
        </div>
        <div class="mt-2">
          <label class="block text-xs text-slate-500">Round count (evaluate in past N rounds)</label>
          <input class="round-count border rounded px-2 py-1 w-20" placeholder="N" value="1" />
        </div>

      <div class="mt-3">
        <div class="text-xs text-slate-500">Then (action)</div>
        <div class="mt-1 grid grid-cols-1 gap-2">
          <select class="then-action border rounded px-2 py-1"><option value="cooperate">cooperate</option><option value="cheat">cheat</option><option value="random">random</option></select>
        </div>
      </div>
    </div>
  `;
  node.querySelector('.remove-rule').addEventListener('click', ()=>{ node.remove(); renderStrategyJSON(); });
  node.querySelectorAll('select,input').forEach(inp=>inp.addEventListener('change', renderStrategyJSON));
  $('rulesList').appendChild(node);
  renderStrategyJSON();
});

// add If-Then rule (single Past clause inside if)
$('addIfThenRule').addEventListener('click', ()=>{
  const node = document.createElement('div'); node.className='rule-item p-3 border rounded'; node.dataset.kind='ifthen';
  node.innerHTML = `
    <div class="flex items-center justify-between">
      <div class="font-medium">If → Then rule (single past clause)</div>
      <button class="text-xs text-slate-500 remove-rule">Remove</button>
    </div>
      <div class="mt-2">
        <div class="text-xs text-slate-500">Condition (one Past clause)</div>
        <div class="mt-2 cond-past grid grid-cols-3 gap-2">
          <select class="past-actor border rounded px-2 py-1"><option value="you">you</option><option value="opponent">opponent</option></select>
          <select class="past-action border rounded px-2 py-1"><option value="cooperated">cooperated</option><option value="cheated">cheated</option></select>
          <input class="past-count border rounded px-2 py-1" placeholder="n or all" value="1" />
        </div>
        <div class="mt-2">
          <label class="block text-xs text-slate-500">Round count (evaluate in past N rounds)</label>
          <input class="round-count border rounded px-2 py-1 w-20" placeholder="N" value="1" />
        </div>

      <div class="mt-3">
        <div class="text-xs text-slate-500">Then (action)</div>
        <div class="mt-1 grid grid-cols-1 gap-2">
          <select class="then-action border rounded px-2 py-1"><option value="cooperate">cooperate</option><option value="cheat">cheat</option><option value="random">random</option></select>
        </div>
      </div>
    </div>
  `;
  node.querySelector('.remove-rule').addEventListener('click', ()=>{ node.remove(); renderStrategyJSON(); });
  node.querySelectorAll('select,input').forEach(inp=>inp.addEventListener('change', renderStrategyJSON));
  $('rulesList').appendChild(node);
  renderStrategyJSON();
});

// preview updates
['charName','initialAction'].forEach(id=>$(id).addEventListener('change', renderStrategyJSON));

/* ============================
   Tournament engine (leader-side)
   - Pairwise: every pair plays EPOCHS epochs × ROUNDS_PER_EPOCH moves
   - Standard PD payoffs: T=5, R=3, P=1, S=0
   ============================ */
function runTournament(){
  // players list from leaderInfo; if a player hasn't sent a strategy, fallback to default initial=cooperate
  const players = Object.keys(leaderInfo).map(pid => ({
    peerId: pid,
    name: leaderInfo[pid].name || 'Player',
    charName: leaderInfo[pid].charName || 'Unnamed',
    strategy: strategies[pid] || { characterName: leaderInfo[pid].charName || 'Unnamed', initial: 'cooperate', rules: [] }
  }));

  // ensure scores & hist
  players.forEach(p => { p.score = 0; p.strategy._hist = {}; });

  function decideAction(strategy, meId, oppId, roundInEpoch){
    const hist = (strategy._hist[oppId] || []);
    
    // first move of each round always uses initial action
    if(roundInEpoch === 0){
      return strategy.initial || 'cooperate';
    }
    
    // evaluate rules top->bottom, if any rule matches, use its action
    for(const rule of strategy.rules || []){
      if(rule.type === 'ifthen'){
        if(evaluateIfThen(rule, hist)){
          return rule.then.action === 'random' ? (Math.random() < 0.5 ? 'cooperate' : 'cheat') : rule.then.action;
        }
      }
    }
    // only use initial action if no rules match
    return strategy.initial || 'cooperate';
  }

  function evaluateIfThen(rule, history){
    const c = rule.condition;
    if(!c) return false;
    
    // get round count to limit evaluation window
    const roundCount = c.roundCount || 1;
    const relevantHistory = history.slice(-roundCount);
    
    if(c.type === 'past'){
      return evaluatePastCondition(c.past, relevantHistory);
    }
    if(c.type === 'and' && Array.isArray(c.clauses) && c.clauses.length === 2){
      return c.clauses.every(cl => cl.type === 'past' && evaluatePastCondition(cl.past, relevantHistory));
    }
    return false;
  }

  function evaluatePastCondition(p, history){
    if(!p) return false;
    if(!Array.isArray(history) || history.length === 0) return false;
    
    // count how many times the actor performed the specified action in relevantHistory
    let matchCount = 0;
    for(const h of history){
      const actorAction = (p.actor === 'you') ? h.me : h.opp;
      if((p.action === 'cooperated' && actorAction === 'cooperate') || (p.action === 'cheated' && actorAction === 'cheat')){
        matchCount++;
      }
    }
    
    // check if match count meets the requirement
    const requiredCount = (p.count === 'all') ? history.length : (parseInt(p.count) || 0);
    return matchCount >= requiredCount;
  }

  // reset logs
  tournamentLogs = [];

  // pairs
  const pairs = [];
  for(let i=0;i<players.length;i++){
    for(let j=i+1;j<players.length;j++) pairs.push([players[i], players[j]]);
  }

  // simulate asynchronously so UI can update
  (async ()=>{
    for(let epoch=0; epoch<EPOCHS; epoch++){
      for(const [A,B] of pairs){
        const histAB = A.strategy._hist[B.peerId] = A.strategy._hist[B.peerId] || [];
        const histBA = B.strategy._hist[A.peerId] = B.strategy._hist[A.peerId] || [];
        for(let r=0;r<ROUNDS_PER_EPOCH;r++){
          const aAct = decideAction(A.strategy, A.peerId, B.peerId, r);
          const bAct = decideAction(B.strategy, B.peerId, A.peerId, r);
          histAB.push({me: aAct, opp: bAct});
          histBA.push({me: bAct, opp: aAct});
          // payoff
          let aScore=0, bScore=0;
          if(aAct==='cooperate' && bAct==='cooperate'){ aScore+=3; bScore+=3; }
          else if(aAct==='cooperate' && bAct==='cheat'){ aScore+=0; bScore+=5; }
          else if(aAct==='cheat' && bAct==='cooperate'){ aScore+=5; bScore+=0; }
          else { aScore+=1; bScore+=1; }
          A.score += aScore; B.score += bScore;

          // log line: character1 - character2: action1 - action2 : point1 - point2
          const line = `${A.charName} - ${B.charName}: ${aAct} - ${bAct} : ${aScore} - ${bScore}`;
          tournamentLogs.push(line);
        }
        // update leaderInfo points
        leaderInfo[A.peerId].points = Math.round(A.score || 0);
        leaderInfo[B.peerId].points = Math.round(B.score || 0);
        renderLeaderboard(); // broadcast updates
        await new Promise(res => setTimeout(res, 30));
      }
    }
    locked = false; // allow next tournament
    for(const pid in connections) {
      try{ connections[pid].send(JSON.stringify({type:'tournament-end'})); }catch(e){}
    }
    alert('Tournament finished!');
    renderLogsView();
  })();
}

function renderLogsView(){
  const el = $('logsView');
  if(!el) return;
  el.textContent = tournamentLogs.join('\n');
}

// Download and clear logs actions
document.addEventListener('click', (e)=>{
  if(e.target && e.target.id === 'downloadLogs'){
    const blob = new Blob([tournamentLogs.join('\n')], {type:'text/plain'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'tournament-logs.txt';
    document.body.appendChild(a);
    a.click();
    setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 0);
  }
  if(e.target && e.target.id === 'clearLogs'){
    tournamentLogs = [];
    renderLogsView();
  }
});

/* ============================
   Small UX: render strategy preview when player edits
   ============================ */
function updateStrategyPreview(){
  const s = buildStrategyFromUI();
  $('strategyJSON').textContent = JSON.stringify(s, null, 2);
}

// update preview when strategy area changed
document.addEventListener('change', updateStrategyPreview);
document.addEventListener('input', updateStrategyPreview);

// initial preview on load
updateStrategyPreview();

</script>
</body>
</html>
